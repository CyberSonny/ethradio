///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      17/Feb/2010  19:00:10 /
// IAR C/C++ Compiler V5.30.0.20166/W32, Evaluation Version  for Atmel AVR    /
// Copyright 1996-2009 IAR Systems AB.                                        /
//                                                                            /
//    Source file  =  G:\AVR\EthRadio_buf_inline\http_get.c                   /
//    Command line =  --string_literals_in_flash                              /
//                    G:\AVR\EthRadio_buf_inline\http_get.c --cpu=m32 -ms -o  /
//                    G:\AVR\EthRadio_buf_inline\Debug\Obj\ -lC               /
//                    G:\AVR\EthRadio_buf_inline\Debug\List\ -lB              /
//                    G:\AVR\EthRadio_buf_inline\Debug\List\                  /
//                    --initializers_in_flash -s9 --no_code_motion --debug    /
//                    -DENABLE_BIT_DEFINITIONS -e -I "C:\Program Files\IAR    /
//                    Systems\Embedded Workbench Evaluation 5.3\avr\INC\" -I  /
//                    "C:\Program Files\IAR Systems\Embedded Workbench        /
//                    Evaluation 5.3\avr\INC\CLIB\" --eeprom_size 1024        /
//                    --lock_regs=1                                           /
//    List file    =  G:\AVR\EthRadio_buf_inline\Debug\List\http_get.s90      /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME http_get

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?Register_R10_is_cg_reg
        EXTERN ?Register_R11_is_cg_reg
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?Register_R5_is_cg_reg
        EXTERN ?Register_R6_is_cg_reg
        EXTERN ?Register_R7_is_cg_reg
        EXTERN ?Register_R8_is_cg_reg
        EXTERN ?Register_R9_is_cg_reg
        EXTERN ?need_segment_init
        EXTERN __eeget16_16
        EXTERN __eeget32_16
        EXTERN __eeget8_16

        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBLIC AddGETsocket
        PUBLIC GET_WINDOW_STATE
        PUBLIC StartGET
        PUBLIC StopGET
        PUBWEAK _A_PORTD
        PUBWEAK _A_SPDR
        PUBWEAK _A_SPSR
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC get_sock

        EXTERN AddTCPsocket
        EXTERN TCPconnect
        EXTERN LCD_fprintline
        EXTERN LCD_putMETA
        EXTERN stricmp_P
        EXTERN LCD_putBR
        EXTERN LCD_softCLR
        EXTERN MP3fifo_free
        EXTERN _i2a
        EXTERN ETHfifo_CNT
        EXTERN ETHfifo_pRD
        EXTERN ETHfifo_pWR
        EXTERN IP
        EXTERN MASK_IP
        EXTERN MP3fifo_pRD
        EXTERN MP3fifo_pWR
        EXTERN OUTG_IP
        EXTERN PLAYER_STATE
        EXTERN debug_addr
        EXTERN stationNum
        EXTERN station_list

// G:\AVR\EthRadio_buf_inline\http_get.c
//    1 /* Name: http_get.c
//    2  * Project: uNikeE - Software Ethernet MAC and upper layers stack
//    3  * Author: Dmitry Oparin aka Rst7/CBSIE
//    4  * Creation Date: 25-Jan-2009
//    5  * Copyright: (C)2008,2009 by Rst7/CBSIE
//    6  * License: GNU GPL v3 (see http://www.gnu.org/licenses/gpl-3.0.txt)
//    7  */
//    8 
//    9 #include "nike_e.h"

        ASEGN ABSOLUTE:DATA:NOROOT,02eH
// <__C30> volatile __io _A_SPSR
_A_SPSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,02fH
// <__C32> volatile __io _A_SPDR
_A_SPDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,032H
// <__C38> volatile __io _A_PORTD
_A_PORTD:
        DS8 1
//   10 #include "tcp.h"
//   11 #include "pgmspace.h"
//   12 #include "vs.h"
//   13 #include "compiler.h"
//   14 #include "FIFO.h"
//   15 #include "http_get.h"
//   16 #include "LCD.h"
//   17 #include "station.h"
//   18 #include "player.h"
//   19 #include "io.h"
//   20 //#include "network_addr.h"
//   21 
//   22 extern UINT32 IP;
//   23 extern UINT32 MASK_IP;
//   24 extern volatile UREG PLAYER_STATE;

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   25 GET_SOCK get_sock;
get_sock:
        DS8 81
//   26 

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   27 volatile UINT8 GET_WINDOW_STATE=GET_WINDOW_STATE_UPDATE;
GET_WINDOW_STATE:
        DS8 1
//   28 
//   29 __z void _i2a(char *s, UINT16 v);
//   30 
//   31 extern __eeprom UINT32 OUTG_IP[2];
//   32 //extern UINT32 OUTG_IP[2];
//   33 
//   34 extern void *debug_addr;
//   35 
//   36 
//   37 #pragma inline = forced
//   38 UINT32 _MP3fifo_free(void)
//   39 {
//   40 	UINT32 free;
//   41 	if(MP3fifo_pRD > MP3fifo_pWR)
//   42 	{
//   43 		free = MP3fifo_pRD-MP3fifo_pWR;
//   44 	}
//   45 	else if(MP3fifo_pRD < MP3fifo_pWR)
//   46 	{
//   47 		free = MP3fifo_pEND-MP3fifo_pWR+1+MP3fifo_pRD-MP3fifo_pSTART;
//   48 	}
//   49 	else
//   50 	{
//   51 		free = MP3fifo_pEND-MP3fifo_pSTART+1;
//   52 	}
//   53 	return free-1;
//   54 }
//   55 

        RSEG CODE:CODE:NOROOT(1)
//   56 void AddGETsocket(void)
AddGETsocket:
//   57 {
//   58   __x UREG GET_hook(UREG state, UREG len, UINT8 *data, TCP_SOCK *_s);
//   59   get_sock.sock.type=TCP_TYPE_CLIENT;
        LDI     R30, LOW(get_sock)
        LDI     R31, (get_sock) >> 8
        LDI     R16, 2
        STD     Z+2, R16
//   60   get_sock.sock.state=TCP_STATE_CLOSED;
        LDI     R16, 0
        STD     Z+27, R16
//   61   get_sock.sock.hook=GET_hook;
        LDI     R16, LOW(GET_hook/2)
        LDI     R17, (GET_hook/2) >> 8
        STD     Z+3, R16
        STD     Z+4, R17
//   62   get_sock.sock.win=htons(SPEC_MAX_WIN);
        LDI     R19, 128
        LDI     R18, 52
        STD     Z+29, R18
        STD     Z+30, R19
//   63   debug_addr=&get_sock;
        STS     debug_addr, R30
        STS     (debug_addr + 1), R31
//   64   AddTCPsocket(&get_sock.sock);
        JMP     AddTCPsocket
//   65 }
//   66 extern volatile UREG is_playing;
//   67 extern volatile UREG stationNum;

        RSEG CODE:CODE:NOROOT(1)
//   68 void StartGET(void)
StartGET:
//   69 {  
        ST      -Y, R7
        ST      -Y, R6
        ST      -Y, R5
        ST      -Y, R4
        ST      -Y, R27
        ST      -Y, R26
        ST      -Y, R25
        ST      -Y, R24
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R7_is_cg_reg
//   70   if (get_sock.sock.state==TCP_STATE_CLOSED) 
        LDS     R16, (get_sock + 27)
        TST     R16
        BREQ    $+2+2
        RJMP    ??StartGET_0
//   71   {
//   72     MP3fifo_pWR= MP3fifo_pRD= MP3fifo_pSTART; 
        LDI     R16, 0
        LDI     R19, 0
        LDI     R30, LOW(MP3fifo_pRD)
        LDI     R31, (MP3fifo_pRD) >> 8
        ST      Z, R16
        STD     Z+1, R16
        STD     Z+2, R16
        STD     Z+3, R16
        LDI     R30, LOW(MP3fifo_pWR)
        LDI     R31, (MP3fifo_pWR) >> 8
        ST      Z, R16
        STD     Z+1, R16
        STD     Z+2, R16
        STD     Z+3, R16
//   73     ETHfifo_pWR= ETHfifo_pRD= ETHfifo_pSTART; 
        LDI     R16, 69
        LDI     R17, 201
        LDI     R18, 1
        LDI     R30, LOW(ETHfifo_pRD)
        LDI     R31, (ETHfifo_pRD) >> 8
        ST      Z, R16
        STD     Z+1, R17
        STD     Z+2, R18
        STD     Z+3, R19
        LDI     R30, LOW(ETHfifo_pWR)
        LDI     R31, (ETHfifo_pWR) >> 8
        ST      Z, R16
        STD     Z+1, R17
        STD     Z+2, R18
        STD     Z+3, R19
//   74     ETHfifo_CNT=0;
        STS     ETHfifo_CNT, R19
//   75     GET_WINDOW_STATE=GET_WINDOW_STATE_UPDATE;
        STS     GET_WINDOW_STATE, R19
//   76     PLAYER_STATE=PLAYER_STATE_STOPED;
        STS     PLAYER_STATE, R19
//   77     UINT32 IPsrc=station_list[stationNum].IP;
        LDS     R17, stationNum
        LDI     R16, 54
        MUL     R17, R16
        LDI     R20, LOW(station_list)
        LDI     R21, (station_list) >> 8
        ADD     R20, R0
        ADC     R21, R1
        CALL    __eeget32_16
        MOVW    R25:R24, R17:R16
        MOVW    R27:R26, R19:R18
//   78     UINT16 port = station_list[stationNum].port;  
        LDI     R20, LOW((station_list + 4))
        LDI     R21, HIGH((station_list + 4))
        LDS     R17, stationNum
        LDI     R16, 54
        MUL     R17, R16
        ADD     R20, R0
        ADC     R21, R1
        CALL    __eeget16_16
        MOVW    R23:R22, R17:R16
//   79     if ((IP&MASK_IP)==(IPsrc&MASK_IP)) get_sock.sock.ACKNO=IPsrc;// без шлюза     
        LDI     R30, LOW(IP)
        LDI     R31, (IP) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        LDI     R30, LOW(MASK_IP)
        LDI     R31, (MASK_IP) >> 8
        LD      R0, Z
        LDD     R1, Z+1
        LDD     R2, Z+2
        LDD     R3, Z+3
        AND     R16, R0
        AND     R17, R1
        AND     R18, R2
        AND     R19, R3
        MOVW    R5:R4, R1:R0
        MOVW    R7:R6, R3:R2
        MOVW    R1:R0, R25:R24
        MOVW    R3:R2, R27:R26
        AND     R0, R4
        AND     R1, R5
        AND     R2, R6
        AND     R3, R7
        CP      R16, R0
        CPC     R17, R1
        CPC     R18, R2
        CPC     R19, R3
        BRNE    ??StartGET_1
        LDI     R30, LOW(get_sock)
        LDI     R31, (get_sock) >> 8
        STD     Z+23, R24
        STD     Z+24, R25
        STD     Z+25, R26
        STD     Z+26, R27
        RJMP    ??StartGET_2
//   80      else get_sock.sock.ACKNO=OUTG_IP[1]; // идем через шлюз
??StartGET_1:
        LDI     R20, LOW((OUTG_IP + 4))
        LDI     R21, HIGH((OUTG_IP + 4))
        CALL    __eeget32_16
        LDI     R30, LOW(get_sock)
        LDI     R31, (get_sock) >> 8
        STD     Z+23, R16
        STD     Z+24, R17
        STD     Z+25, R18
        STD     Z+26, R19
//   81     TCPconnect(&get_sock.sock,IPsrc,port);     
??StartGET_2:
        MOVW    R21:R20, R23:R22
        MOVW    R17:R16, R25:R24
        MOVW    R19:R18, R27:R26
        LDI     R26, LOW(get_sock)
        LDI     R27, (get_sock) >> 8
        CALL    TCPconnect
//   82   }
//   83 }
??StartGET_0:
        LD      R24, Y+
        LD      R25, Y+
        LD      R26, Y+
        LD      R27, Y+
        LD      R4, Y+
        LD      R5, Y+
        LD      R6, Y+
        LD      R7, Y+
        RET
//   84 

        RSEG CODE:CODE:NOROOT(1)
//   85 void StopGET(void)
StopGET:
//   86 {
//   87   //is_playing=0;
//   88   CloseTCPsocket(&get_sock.sock);
        LDI     R16, 5
        STS     (get_sock + 27), R16
//   89 }
        RET
//   90 
//   91 enum HTTP_GET_STATE
//   92 {
//   93   _GET_STOP=0, //Остановленно
//   94   _GET_CONREQ, //Запрос соединения
//   95   _GET_SENDREQ, //Посылка HTTP-запроса
//   96   _GET_WAITACK, //Ожидание подтверждения посылки
//   97   _GET_HEADER, //Прием заголовка
//   98   _GET_BODY, //Прием тела
//   99   _GET_METADATA //Прием метаданных
//  100 };
//  101 
//  102 extern __x_z UREG stricmp_P(const char *s, const char __flash *d);
//  103 

        RSEG CODE:CODE:NOROOT(1)
//  104 static __z UINT16 a2i(const char *s)
a2i:
//  105 {
//  106   UREG c;
//  107   UINT16 i=0;
        LDI     R16, 0
        LDI     R17, 0
        LDI     R18, 10
        RJMP    ??a2i_0
//  108   for(;;)
//  109   {
//  110     c=*s++;
//  111     if (c==' ') continue;
//  112     c-='0';
//  113     if (c>9) return i;
//  114     i*=10;
//  115     i+=c;
??a2i_1:
        MUL     R18, R17
        MOV     R19, R0
        MUL     R18, R16
        ADD     R19, R1
        MOV     R16, R0
        MOV     R17, R19
        LDI     R21, 0
        ADD     R16, R20
        ADC     R17, R21
??a2i_0:
        LD      R20, Z+
        CPI     R20, 32
        BREQ    ??a2i_0
        SUBI    R20, 48
        CPI     R20, 10
        BRCS    ??a2i_1
        RET
//  116   }
//  117 }
//  118 

        RSEG CODE:CODE:NOROOT(1)
//  119 static __x UREG GET_hook_DATA_RX(UREG len, UINT8 *data, GET_SOCK *s)
GET_hook_DATA_RX:
//  120 {
        ST      -Y, R11
        ST      -Y, R10
        ST      -Y, R9
        ST      -Y, R8
        ST      -Y, R7
        ST      -Y, R6
        ST      -Y, R5
        ST      -Y, R4
        ST      -Y, R25
        ST      -Y, R24
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R7_is_cg_reg
        REQUIRE ?Register_R8_is_cg_reg
        REQUIRE ?Register_R9_is_cg_reg
        REQUIRE ?Register_R10_is_cg_reg
        REQUIRE ?Register_R11_is_cg_reg
        MOV     R8, R16
        MOVW    R11:R10, R27:R26
        MOVW    R25:R24, R19:R18
//  121   UREG c;
//  122   UREG state=s->state;
        MOVW    R31:R30, R19:R18
        LDD     R9, Z+43
//  123   UINT32 pWR;      
//  124   UINT16 bl;
//  125   pWR = MP3fifo_pWR; // Голова    
        LDI     R30, LOW(MP3fifo_pWR)
        LDI     R31, (MP3fifo_pWR) >> 8
        LD      R4, Z
        LDD     R5, Z+1
        LDD     R6, Z+2
        LDD     R7, Z+3
//  126     
//  127   if (state==_GET_BODY) // Заходим сюда - если идет прием тела
        LDI     R16, 5
        CP      R9, R16
        BREQ    $+2+2
        RJMP    ??GET_hook_DATA_RX_0
//  128   {    
//  129     if (PLAYER_STATE!=PLAYER_STATE_PLAYING) 
        LDS     R16, PLAYER_STATE
        CPI     R16, 2
        BREQ    ??GET_hook_DATA_RX_1
//  130     {      
//  131       if (PLAYER_STATE!=PLAYER_STATE_BUFFERING) LCD_fprintline(1,"Buffering");     
        LDS     R16, PLAYER_STATE
        CPI     R16, 1
        BREQ    ??GET_hook_DATA_RX_2
        LDI     R30, LOW(`?<Constant "Buffering">`)
        LDI     R31, (`?<Constant "Buffering">`) >> 8
        LDI     R16, 1
        CALL    LCD_fprintline
//  132       PLAYER_STATE=PLAYER_STATE_BUFFERING;
??GET_hook_DATA_RX_2:
        LDI     R16, 1
        STS     PLAYER_STATE, R16
//  133     }
//  134 L_BODY:
//  135   {
//  136     UREG addr;
//  137     FM_CS_ENABLE();   // Выбираем FRAM
??GET_hook_DATA_RX_1:
        CBI     0x12, 0x04
//  138     SPDR=FM_WREN;     // Разрешаем запись
        LDI     R16, 6
        OUT     0x0F, R16
//  139     while (!(SPSR & (1<<SPIF)));               
??GET_hook_DATA_RX_3:
        SBIS    0x0E, 0x07
        RJMP    ??GET_hook_DATA_RX_3
//  140     FM_CS_DISABLE();
        SBI     0x12, 0x04
//  141     FM_CS_ENABLE();   // Выбираем FRAM
        CBI     0x12, 0x04
//  142     SPDR=FM_WRITE;    // Операция - "запись"
        LDI     R16, 2
        OUT     0x0F, R16
//  143     addr=(UREG)(pWR>>16);
//  144     while (!(SPSR & (1<<SPIF)));
??GET_hook_DATA_RX_4:
        SBIS    0x0E, 0x07
        RJMP    ??GET_hook_DATA_RX_4
//  145     SPDR=addr;  // Начальный адрес - голова [24..16]
        OUT     0x0F, R6
//  146     addr=(UREG)(pWR>>8);
//  147     while (!(SPSR & (1<<SPIF)));       
??GET_hook_DATA_RX_5:
        SBIS    0x0E, 0x07
        RJMP    ??GET_hook_DATA_RX_5
//  148     SPDR=addr;  // Начальный адрес - голова [15..8]
        OUT     0x0F, R5
//  149     addr=(UREG)(pWR);
//  150     while (!(SPSR & (1<<SPIF)));
??GET_hook_DATA_RX_6:
        SBIS    0x0E, 0x07
        RJMP    ??GET_hook_DATA_RX_6
//  151     SPDR=addr;    //Начальный адрес - голова [7..0]    
        OUT     0x0F, R4
//  152     while (!(SPSR & (1<<SPIF)));    
??GET_hook_DATA_RX_7:
        SBIS    0x0E, 0x07
        RJMP    ??GET_hook_DATA_RX_7
//  153   }
//  154 L_BODY2:    
//  155     //Быстрая обработка данных тела
//  156     if (!len) goto GET_hook_DATA_RX_exit;
??GET_hook_DATA_RX_8:
        TST     R8
        BRNE    $+2+2
        RJMP    ??GET_hook_DATA_RX_9
//  157     bl=s->block_length; // "вспомним" размер блока мета-данных        
        MOVW    R31:R30, R25:R24
        LDD     R26, Z+45
        LDD     R27, Z+46
//  158     do
//  159     {            
//  160       UREG c=*data++; //читаем очередной байт тела
??GET_hook_DATA_RX_10:
        MOVW    R31:R30, R11:R10
        LD      R17, Z+
        MOVW    R11:R10, R31:R30
//  161       if (bl) //Только если мы знаем, что метаданные присутствуют
        MOV     R16, R26
        OR      R16, R27
        BREQ    ??GET_hook_DATA_RX_11
//  162       {	
//  163 	if (!(--bl))
        SBIW    R27:R26, 1
        BRNE    ??GET_hook_DATA_RX_11
//  164 	{
//  165 	  //Блок закончился, в c - размер метаданных
//  166           if (!c)                          // Длина метаданных 0 (их нет)
        TST     R17
        BRNE    ??GET_hook_DATA_RX_12
//  167           {
//  168 //             META_len=0;
//  169 //             pMETA_buf=&META_buf[0];
//  170              bl=s->metadata_interval;
        MOVW    R31:R30, R25:R24
        LDD     R26, Z+47
        LDD     R27, Z+48
//  171              s->block_length=bl;
        STD     Z+45, R26
        STD     Z+46, R27
//  172              continue;
        RJMP    ??GET_hook_DATA_RX_13
//  173           }
//  174           s->state=state=_GET_METADATA;
??GET_hook_DATA_RX_12:
        LDI     R16, 6
        MOVW    R31:R30, R25:R24
        STD     Z+43, R16
//  175           s->block_length=c*16;           // рассчитаем и запомним длину блока с мп3 данными
        LDI     R16, 16
        MUL     R17, R16
        STD     Z+45, R0
        STD     Z+46, R1
//  176 	  len--;
        DEC     R8
//  177           LCD_putMETA(0,0); 
        LDI     R17, 0
        LDI     R16, 0
        CALL    LCD_putMETA
//  178 	  goto L_METADATA;                // идем на обработку метаданных
        RJMP    ??GET_hook_DATA_RX_14
//  179 	}
//  180       }      
//  181         UREG f=0;
??GET_hook_DATA_RX_11:
        LDI     R16, 0
//  182         SPDR = c; // Записали байт в FIFO      
        OUT     0x0F, R17
//  183         pWR += 1; // Сдвигаем голову        
        LDI     R17, 1
        ADD     R4, R17
        ADC     R5, R16
        ADC     R6, R16
        ADC     R7, R16
//  184         if (pWR > MP3fifo_pEND) f=1;
        LDI     R17, 68
        CP      R4, R17
        LDI     R17, 201
        CPC     R5, R17
        LDI     R17, 1
        CPC     R6, R17
        LDI     R17, 0
        CPC     R7, R16
        BRCS    ??GET_hook_DATA_RX_15
        LDI     R16, 1
//  185 	while (!(SPSR & (1<<SPIF))); // wait SPI comm. finished 
??GET_hook_DATA_RX_15:
        SBIS    0x0E, 0x07
        RJMP    ??GET_hook_DATA_RX_15
//  186 	if (f) 
        TST     R16
        BREQ    ??GET_hook_DATA_RX_13
//  187         {
//  188           UREG addr;
//  189           pWR=MP3fifo_pSTART; // дошли до крайней ячейки - надо перепрыгивать вниз                
        CLR     R4
        CLR     R5
        CLR     R6
        CLR     R7
//  190           FM_CS_DISABLE();
        SBI     0x12, 0x04
//  191           FM_CS_ENABLE();   // Выбираем FRAM
        CBI     0x12, 0x04
//  192           SPDR=FM_WREN;     // Разрешаем запись
        LDI     R16, 6
        OUT     0x0F, R16
//  193           while (!(SPSR & (1<<SPIF)));               
??GET_hook_DATA_RX_16:
        SBIS    0x0E, 0x07
        RJMP    ??GET_hook_DATA_RX_16
//  194           FM_CS_DISABLE();
        SBI     0x12, 0x04
//  195           FM_CS_ENABLE();   // Выбираем FRAM
        CBI     0x12, 0x04
//  196           SPDR=FM_WRITE;    // Операция - "запись"
        LDI     R16, 2
        OUT     0x0F, R16
//  197           addr=(UREG)(pWR>>16);
//  198           while (!(SPSR & (1<<SPIF)));
??GET_hook_DATA_RX_17:
        SBIS    0x0E, 0x07
        RJMP    ??GET_hook_DATA_RX_17
//  199           SPDR=addr;  // Начальный адрес - голова [24..16]
        OUT     0x0F, R17
//  200           addr=(UREG)(pWR>>8);
//  201           while (!(SPSR & (1<<SPIF)));       
??GET_hook_DATA_RX_18:
        SBIS    0x0E, 0x07
        RJMP    ??GET_hook_DATA_RX_18
//  202           SPDR=addr;  // Начальный адрес - голова [15..8]
        OUT     0x0F, R17
//  203           addr=(UREG)(pWR);          
//  204           while (!(SPSR & (1<<SPIF)));
??GET_hook_DATA_RX_19:
        SBIS    0x0E, 0x07
        RJMP    ??GET_hook_DATA_RX_19
//  205           SPDR=addr;    //Начальный адрес - голова [7..0]    
        OUT     0x0F, R17
//  206           while (!(SPSR & (1<<SPIF)));  
??GET_hook_DATA_RX_20:
        SBIS    0x0E, 0x07
        RJMP    ??GET_hook_DATA_RX_20
//  207         }	
//  208     }
//  209     while(--len);
??GET_hook_DATA_RX_13:
        DEC     R8
        BREQ    $+2+2
        RJMP    ??GET_hook_DATA_RX_10
//  210     s->block_length=bl;    
??GET_hook_DATA_RX_21:
        MOVW    R31:R30, R25:R24
        STD     Z+45, R26
        STD     Z+46, R27
//  211 
//  212 GET_hook_DATA_RX_exit:
//  213     
//  214     FM_CS_DISABLE();
??GET_hook_DATA_RX_9:
        SBI     0x12, 0x04
//  215     MP3fifo_pWR = pWR;        
        LDI     R30, LOW(MP3fifo_pWR)
        LDI     R31, (MP3fifo_pWR) >> 8
        ST      Z, R4
        STD     Z+1, R5
        STD     Z+2, R6
        STD     Z+3, R7
//  216     // Записали пакет
//  217     // Теперь высчитываем оставшееся место в буфере FRAM 
//  218     // Устанавливаем размер окна сокета равный числу свободных байт в буфере FRAM
//  219     UINT32 freeFIFO=_MP3fifo_free();
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        LDI     R30, LOW(MP3fifo_pRD)
        LDI     R31, (MP3fifo_pRD) >> 8
        LD      R20, Z
        LDD     R21, Z+1
        LDD     R22, Z+2
        LDD     R23, Z+3
        CP      R16, R20
        CPC     R17, R21
        CPC     R18, R22
        CPC     R19, R23
        MOVW    R17:R16, R21:R20
        MOVW    R19:R18, R23:R22
        LDI     R30, LOW(MP3fifo_pWR)
        LDI     R31, (MP3fifo_pWR) >> 8
        LD      R20, Z
        LDD     R21, Z+1
        LDD     R22, Z+2
        LDD     R23, Z+3
        BRCC    ??GET_hook_DATA_RX_22
        SUB     R16, R20
        SBC     R17, R21
        SBC     R18, R22
        SBC     R19, R23
        RJMP    ??GET_hook_DATA_RX_23
??GET_hook_DATA_RX_22:
        CP      R16, R20
        CPC     R17, R21
        CPC     R18, R22
        CPC     R19, R23
        LDI     R16, 68
        LDI     R17, 201
        LDI     R18, 1
        LDI     R19, 0
        BRCC    ??GET_hook_DATA_RX_23
        SUB     R16, R20
        SBC     R17, R21
        SBC     R18, R22
        SBC     R19, R23
        LDI     R30, LOW(MP3fifo_pRD)
        LDI     R31, (MP3fifo_pRD) >> 8
        LD      R20, Z
        LDD     R21, Z+1
        LDD     R22, Z+2
        LDD     R23, Z+3
        ADD     R16, R20
        ADC     R17, R21
        ADC     R18, R22
        ADC     R19, R23
??GET_hook_DATA_RX_23:
        SUBI    R16, 1
        SBCI    R17, 0
        SBCI    R18, 0
        SBCI    R19, 0
//  220     if (freeFIFO < TCP_MAX_DATA_LEN)
        CPI     R16, 64
        LDI     R20, 5
        CPC     R17, R20
        LDI     R20, 0
        CPC     R18, R20
        CPC     R19, R20
        BRCC    ??GET_hook_DATA_RX_24
//  221     {   
//  222       // считаем что в FIFO места уже нет - обнуляем окно
//  223       // соответственно можно начать играть в основном цикле
//  224       GET_WINDOW_STATE=GET_WINDOW_STATE_ZERO;
        LDI     R16, 1
        STS     GET_WINDOW_STATE, R16
//  225       freeFIFO=0; 
        LDI     R16, 0
        LDI     R17, 0
        RJMP    ??GET_hook_DATA_RX_25
//  226       #ifdef CONSOLE_DEBUG
//  227       _print_fstr("\r\nZEROWIN");
//  228       #endif
//  229     }    
//  230     else if (freeFIFO>=SPEC_MAX_WIN) freeFIFO=SPEC_MAX_WIN;
??GET_hook_DATA_RX_24:
        CPI     R16, 128
        LDI     R20, 52
        CPC     R17, R20
        SBCI    R18, 0
        SBCI    R19, 0
        BRCS    ??GET_hook_DATA_RX_25
        LDI     R16, 128
        LDI     R17, 52
//  231 //    else if (freeFIFO>=(0xFFFF-512)) freeFIFO=0xFFFF;
//  232 //    else freeFIFO+=512;
//  233     s->sock.win=htons((UINT16)(freeFIFO)); // меняем размер окна
??GET_hook_DATA_RX_25:
        MOVW    R31:R30, R25:R24
        STD     Z+29, R17
        STD     Z+30, R16
//  234     return 0; // Данные тела кончились - выходим...
        LDI     R16, 0
        LD      R24, Y+
        LD      R25, Y+
        LD      R4, Y+
        LD      R5, Y+
        LD      R6, Y+
        LD      R7, Y+
        LD      R8, Y+
        LD      R9, Y+
        LD      R10, Y+
        LD      R11, Y+
        RET
//  235   }
//  236   if (state==_GET_METADATA)
??GET_hook_DATA_RX_0:
        LDI     R16, 6
        CP      R9, R16
        BRNE    ??GET_hook_DATA_RX_26
//  237   {
//  238   L_METADATA:
//  239     //Быстрая обработка метаданных
//  240     if (!len) goto GET_hook_DATA_RX_exit;//{FM_CS_DISABLE(); return 0;}
??GET_hook_DATA_RX_14:
        TST     R8
        BRNE    $+2+2
        RJMP    ??GET_hook_DATA_RX_9
//  241     bl=s->block_length;
        MOVW    R31:R30, R25:R24
        LDD     R26, Z+45
        LDD     R27, Z+46
        RJMP    ??GET_hook_DATA_RX_27
//  242     do
//  243     {
//  244       if (!(--bl))
//  245       {
//  246 	//Блок закончился, в c - размер метаданных
//  247 	s->state=state=_GET_BODY;
//  248 	s->block_length=s->metadata_interval;
//  249 	len--;
//  250 	goto L_BODY2;
//  251       }
//  252       UREG c=*data++;
??GET_hook_DATA_RX_28:
        MOVW    R31:R30, R11:R10
        LD      R17, Z+
        MOVW    R11:R10, R31:R30
//  253      //Тут можно накапливать байты метаданных, если надо
//  254      //UDR=c; // выводим в консоль
//  255 //     if (META_len++<31) *pMETA_buf++=c;
//  256      LCD_putMETA(1,c); 
        LDI     R16, 1
        CALL    LCD_putMETA
//  257     }
//  258     while(--len);
        DEC     R8
        BRNE    $+2+2
        RJMP    ??GET_hook_DATA_RX_21
??GET_hook_DATA_RX_27:
        SBIW    R27:R26, 1
        BRNE    ??GET_hook_DATA_RX_28
        LDI     R16, 5
        MOVW    R31:R30, R25:R24
        STD     Z+43, R16
        LDD     R16, Z+47
        LDD     R17, Z+48
        STD     Z+45, R16
        STD     Z+46, R17
        DEC     R8
        RJMP    ??GET_hook_DATA_RX_8
//  259     s->block_length=bl;
//  260   }
//  261   // Идет прием... 
//  262   if (!len) goto GET_hook_DATA_RX_exit;//{FM_CS_DISABLE();return 0;}
??GET_hook_DATA_RX_26:
        TST     R8
        BRNE    $+2+2
        RJMP    ??GET_hook_DATA_RX_9
//  263   UREG pos=s->header_pos; // pos - текущая позиция в строке-заголовке
        MOVW    R31:R30, R19:R18
        LDD     R18, Z+44
//  264   // Пробежимся по заголовкам
//  265   do 
//  266   {
//  267     c=*data++;
??GET_hook_DATA_RX_29:
        MOVW    R31:R30, R11:R10
        LD      R16, Z+
        MOVW    R11:R10, R31:R30
//  268     switch(state)
        LDI     R17, 4
        CP      R9, R17
        BRNE    ??GET_hook_DATA_RX_30
//  269     {
//  270         case _GET_HEADER: 
//  271         // Если сейчас идет прием заголовка (Header)  
//  272           if (c==10) // поймали '\n'  (Конец строки)
        CPI     R16, 10
        BRNE    ??GET_hook_DATA_RX_31
//  273           {      
//  274             s->req[pos]=0;
        LDI     R16, 0
        MOVW    R31:R30, R25:R24
        ADD     R30, R18
        ADC     R31, R16
        STD     Z+49, R16
//  275             if (pos) // если позиция в строке не нулевая
        TST     R18
        BREQ    ??GET_hook_DATA_RX_32
//  276             {       
//  277               if (!stricmp_P(s->req,"icy-metaint")) // поймали укзатель длины блока метаданных?
        LDI     R30, LOW((`?<Constant "Buffering">` + 17))
        LDI     R31, HIGH((`?<Constant "Buffering">` + 17))
        MOVW    R27:R26, R25:R24
        ADIW    R27:R26, 49
        CALL    stricmp_P
        TST     R16
        BRNE    ??GET_hook_DATA_RX_33
//  278               {
//  279                 //Размер блока между метаданными
//  280                 s->metadata_interval=a2i(s->req+12)+1; //Запомним размер блока метаданных (еще вычитываем байт длинны метаданных)
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 61
        RCALL   a2i
        SUBI    R16, 255
        SBCI    R17, 255
        MOVW    R31:R30, R25:R24
        STD     Z+47, R16
        STD     Z+48, R17
        RJMP    ??GET_hook_DATA_RX_34
//  281               }
//  282               else if (!stricmp_P(s->req,"icy-br")) // поймали укзатель битрейта
??GET_hook_DATA_RX_33:
        LDI     R30, LOW((`?<Constant "Buffering">` + 10))
        LDI     R31, HIGH((`?<Constant "Buffering">` + 10))
        MOVW    R27:R26, R25:R24
        ADIW    R27:R26, 49
        CALL    stricmp_P
        TST     R16
        BRNE    ??GET_hook_DATA_RX_34
//  283               {
//  284                 //Битрейт
//  285                 LCD_putBR(s->req+7);
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 56
        CALL    LCD_putBR
//  286               }
//  287             }   
//  288             else // поймали \r\n (Конец заголовков, переключаемся на тело)
//  289             {              
//  290               //__no_operation();
//  291               s->state=state=_GET_BODY;
//  292               s->block_length=s->metadata_interval; // Запоминаем размер блока между метаданными
//  293               len--;
//  294               goto L_BODY; // Перейдем на обработку метаданных
//  295             }
//  296             pos=0; //Начинаем новое накопление строки
??GET_hook_DATA_RX_34:
        LDI     R18, 0
//  297             break;
        RJMP    ??GET_hook_DATA_RX_30
??GET_hook_DATA_RX_32:
        LDI     R16, 5
        MOVW    R31:R30, R25:R24
        STD     Z+43, R16
        LDD     R16, Z+47
        LDD     R17, Z+48
        STD     Z+45, R16
        STD     Z+46, R17
        DEC     R8
        RJMP    ??GET_hook_DATA_RX_1
//  298          }
//  299          if (c==13) break; //Пропускаем
??GET_hook_DATA_RX_31:
        CPI     R16, 13
        BREQ    ??GET_hook_DATA_RX_30
//  300          if (pos<(sizeof(s->req)-1))
        CPI     R18, 31
        BRCC    ??GET_hook_DATA_RX_30
//  301          {
//  302             //Если есть куда сохранять символы, сохраняем название заголовка
//  303            if (c==':') c=0;
        CPI     R16, 58
        BRNE    ??GET_hook_DATA_RX_35
        LDI     R16, 0
//  304            s->req[pos++]=c;
??GET_hook_DATA_RX_35:
        LDI     R19, 0
        MOVW    R31:R30, R25:R24
        ADD     R30, R18
        ADC     R31, R19
        STD     Z+49, R16
        INC     R18
//  305           }
//  306         break;
//  307     }
//  308   }
//  309   while(--len);
??GET_hook_DATA_RX_30:
        DEC     R8
        BREQ    $+2+2
        RJMP    ??GET_hook_DATA_RX_29
//  310   s->header_pos=pos;
        MOVW    R31:R30, R25:R24
        STD     Z+44, R18
//  311   s->state=state;
        STD     Z+43, R9
//  312   goto GET_hook_DATA_RX_exit;
        RJMP    ??GET_hook_DATA_RX_9
        REQUIRE _A_SPSR
        REQUIRE _A_SPDR
        REQUIRE _A_PORTD
//  313 //  FM_CS_DISABLE();
//  314 //  return 0;
//  315 }
//  316 
//  317 //extern volatile UREG stop_req;
//  318 

        RSEG CODE:CODE:NOROOT(1)
//  319 static __x UREG GET_hook(UREG state, UREG len, UINT8 *data, TCP_SOCK *_s)
GET_hook:
//  320 {
        ST      -Y, R10
        ST      -Y, R9
        ST      -Y, R8
        ST      -Y, R7
        ST      -Y, R6
        ST      -Y, R5
        ST      -Y, R4
        ST      -Y, R25
        ST      -Y, R24
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R7_is_cg_reg
        REQUIRE ?Register_R8_is_cg_reg
        REQUIRE ?Register_R9_is_cg_reg
        REQUIRE ?Register_R10_is_cg_reg
        SBIW    R29:R28, 4
        MOV     R22, R16
        MOV     R16, R17
        MOVW    R21:R20, R27:R26
        MOVW    R27:R26, R19:R18
//  321   GET_SOCK *s=(GET_SOCK *)_s;
//  322   UINT32 freeFIFO;
//  323 //  UREG i;
//  324 //  UREG j;
//  325   switch(state)
        DEC     R22
        BREQ    ??GET_hook_0
        SUBI    R22, 2
        BREQ    ??GET_hook_1
        DEC     R22
        BREQ    ??GET_hook_1
        DEC     R22
        BRNE    $+2+2
        RJMP    ??GET_hook_2
        DEC     R22
        BRNE    $+2+2
        RJMP    ??GET_hook_3
        DEC     R22
        BRNE    $+2+2
        RJMP    ??GET_hook_4
        DEC     R22
        BRNE    $+2+2
        RJMP    ??GET_hook_5
        DEC     R22
        BREQ    ??GET_hook_6
        RJMP    ??GET_hook_7
//  326   {
//  327   case TCP_EVENT_CLOSE:
//  328   case TCP_EVENT_ABORT:
//  329     s->state=_GET_STOP;
??GET_hook_1:
        LDI     R16, 0
        MOVW    R31:R30, R19:R18
        STD     Z+43, R16
//  330     s->header_pos=0;
        STD     Z+44, R16
//  331     s->block_length=0;
        STD     Z+45, R16
        STD     Z+46, R16
//  332     s->metadata_interval=0;
        STD     Z+47, R16
        STD     Z+48, R16
//  333     PLAYER_STATE=PLAYER_STATE_STOPED;
        STS     PLAYER_STATE, R16
//  334     if (PLAYER_STATE==PLAYER_STATE_STOPED) 
        LDS     R16, PLAYER_STATE
        TST     R16
        BRNE    ??GET_hook_7
//  335     {
//  336       LCD_fprintline(1,"Stoped");     
        LDI     R30, LOW(`?<Constant "Stoped">`)
        LDI     R31, (`?<Constant "Stoped">`) >> 8
        LDI     R16, 1
        CALL    LCD_fprintline
//  337       LCD_softCLR();     
        CALL    LCD_softCLR
//  338     }
//  339     return 0;
??GET_hook_7:
        LDI     R16, 0
        RJMP    ??GET_hook_8
//  340   case TCP_EVENT_CONREQ:
//  341     s->state=_GET_CONREQ;
??GET_hook_0:
        LDI     R16, 1
        MOVW    R31:R30, R19:R18
??GET_hook_9:
        STD     Z+43, R16
//  342     return 0;
        RJMP    ??GET_hook_7
//  343   case TCP_EVENT_ASYNC_REQ:
//  344     s->sock.async_req=0;
??GET_hook_6:
        LDI     R16, 0
        MOVW    R31:R30, R19:R18
        STD     Z+42, R16
//  345     freeFIFO=MP3fifo_free();
        CALL    MP3fifo_free
//  346     //if (freeFIFO<SPEC_MAX_WIN)
//  347     if (freeFIFO<4*TCP_MAX_DATA_LEN)
        CPI     R16, 0
        LDI     R20, 21
        CPC     R17, R20
        LDI     R20, 0
        CPC     R18, R20
        CPC     R19, R20
        BRCC    ??GET_hook_10
//  348     {
//  349       // пока нет места для приема полноценного окна не делаем асинхронный старт      
//  350       GET_WINDOW_STATE=GET_WINDOW_STATE_ZERO;
        LDI     R16, 1
        STS     GET_WINDOW_STATE, R16
//  351       #ifdef CONSOLE_DEBUG
//  352       _print_fstr("\r\nNO_Async_start");
//  353       #endif
//  354       return 0;
        RJMP    ??GET_hook_7
//  355     }
//  356     #ifdef CONSOLE_DEBUG
//  357     _print_fstr("\r\nAsync_start");
//  358     #endif
//  359     GET_WINDOW_STATE=GET_WINDOW_STATE_UPDATE;
??GET_hook_10:
        STS     GET_WINDOW_STATE, R20
//  360     if (freeFIFO>=SPEC_MAX_WIN) freeFIFO=SPEC_MAX_WIN;
        CPI     R16, 128
        LDI     R20, 52
        CPC     R17, R20
        SBCI    R18, 0
        SBCI    R19, 0
        BRCS    ??GET_hook_11
        LDI     R16, 128
        LDI     R17, 52
//  361     s->sock.win=htons((UINT16)freeFIFO); // запишем фактическое окно
??GET_hook_11:
        MOVW    R31:R30, R27:R26
        STD     Z+29, R17
        STD     Z+30, R16
//  362     s->sock.txreq=TCP_TXREQ_SEND;
        LDI     R16, 3
        STD     Z+41, R16
//  363     return 0;
        RJMP    ??GET_hook_7
//  364   case TCP_EVENT_DATA:
//  365     if (PLAYER_STATE==PLAYER_STATE_STOPREQ)
??GET_hook_4:
        LDS     R17, PLAYER_STATE
        CPI     R17, 3
        BRNE    ??GET_hook_12
//  366     {
//  367       StopGET();
??GET_hook_13:
        LDI     R16, 5
        STS     (get_sock + 27), R16
//  368       return 0;
        RJMP    ??GET_hook_7
//  369     }
//  370     if (s->state==_GET_CONREQ)
??GET_hook_12:
        MOVW    R31:R30, R19:R18
        LDD     R17, Z+43
        CPI     R17, 1
        BRNE    ??GET_hook_14
//  371     {
//  372       s->state=_GET_SENDREQ;
        LDI     R16, 2
        STD     Z+43, R16
//  373       return 1; //Запрос передачи
        LDI     R16, 1
        RJMP    ??GET_hook_8
//  374     }
//  375     if (s->state<_GET_HEADER) return 0;
??GET_hook_14:
        CPI     R17, 4
        BRCS    ??GET_hook_7
//  376     return GET_hook_DATA_RX(len,data,s);
        MOVW    R27:R26, R21:R20
        RCALL   GET_hook_DATA_RX
        RJMP    ??GET_hook_8
//  377   case TCP_EVENT_ACK:
//  378     //Подтверждение данных
//  379     if (PLAYER_STATE==PLAYER_STATE_STOPREQ)
??GET_hook_2:
        LDS     R17, PLAYER_STATE
        CPI     R17, 3
        BREQ    ??GET_hook_13
//  380     {
//  381       StopGET();
//  382       return 0;
//  383     }
//  384     if (s->state==_GET_WAITACK&&len)
        MOVW    R31:R30, R19:R18
        LDD     R17, Z+43
        CPI     R17, 3
        BREQ    $+2+2
        RJMP    ??GET_hook_7
        TST     R16
        BRNE    $+2+2
        RJMP    ??GET_hook_7
//  385     {
//  386       s->state=_GET_HEADER;
        LDI     R16, 4
        RJMP    ??GET_hook_9
//  387     }
//  388     return 0;
//  389   case TCP_EVENT_REGENERATE:
//  390     if (s->state==_GET_WAITACK) s->state=_GET_SENDREQ;
??GET_hook_3:
        MOVW    R31:R30, R19:R18
        LDD     R16, Z+43
        CPI     R16, 3
        BRNE    ??GET_hook_5
        LDI     R16, 2
        STD     Z+43, R16
//  391   case TCP_EVENT_SEND:
//  392   if (s->state==_GET_SENDREQ)
??GET_hook_5:
        MOVW    R31:R30, R19:R18
        LDD     R16, Z+43
        CPI     R16, 2
        BREQ    $+2+2
        RJMP    ??GET_hook_7
//  393     {
//  394       s->state=_GET_WAITACK;
        LDI     R16, 3
        STD     Z+43, R16
//  395       static __flash char req1[]="GET /";     
//  396       static __flash char req2[]=" HTTP/1.0\r\nHost:";        
//  397       static __flash char req3[]="\r\nIcy-MetaData:1\r\nUser-Agent: uEthRadio/0.1\r\nConnection: close\r\n\r\n";
//  398       UREG i=sizeof(req1)-1;
//  399       char __flash *s=req1;
        LDI     R16, LOW(??req1)
        LDI     R17, (??req1) >> 8
//  400       UINT8 *d=data;
        MOVW    R7:R6, R21:R20
        LDI     R18, 5
//  401       do
//  402       {
//  403 	*d++=*s++;// "GET/"
??GET_hook_15:
        MOVW    R31:R30, R17:R16
        LPM     R19, Z+
        MOVW    R17:R16, R31:R30
        MOVW    R31:R30, R7:R6
        ST      Z+, R19
        MOVW    R7:R6, R31:R30
//  404       }
//  405       while(--i);
        DEC     R18
        BRNE    ??GET_hook_15
//  406       UREG s1=0;      
        CLR     R8
//  407       char __eeprom *es;
//  408       es=station_list[stationNum].req;
        LDI     R20, LOW((station_list + 6))
        LDI     R21, HIGH((station_list + 6))
        LDS     R17, stationNum
        LDI     R16, 54
        MUL     R17, R16
        ADD     R20, R0
        ADC     R21, R1
        RJMP    ??GET_hook_16
//  409       
//  410        while(*es)      
//  411       {
//  412             *d++=*es++;//  "запрос"
??GET_hook_17:
        CALL    __eeget8_16
        MOVW    R31:R30, R7:R6
        ST      Z+, R16
        MOVW    R7:R6, R31:R30
        SUBI    R20, 255
        SBCI    R21, 255
//  413             s1++;
        INC     R8
//  414        };
??GET_hook_16:
        CALL    __eeget8_16
        TST     R16
        BRNE    ??GET_hook_17
//  415           
//  416       i=sizeof(req2)-1;
        LDI     R16, 16
        MOV     R10, R16
//  417       s=req2;
        LDI     R16, LOW((??req1 + 6))
        LDI     R17, HIGH((??req1 + 6))
//  418       do
//  419       {
//  420 	*d++=*s++;// "/HTTP1.0 Host:"
??GET_hook_18:
        MOVW    R31:R30, R17:R16
        LPM     R18, Z+
        MOVW    R17:R16, R31:R30
        MOVW    R31:R30, R7:R6
        ST      Z+, R18
        MOVW    R7:R6, R31:R30
//  421       }
//  422       while(--i);     
        DEC     R10
        BRNE    ??GET_hook_18
//  423       
//  424       __no_init char i2a_buf[4];
//  425       char *sIP = i2a_buf;
        MOVW    R5:R4, R29:R28
//  426       UINT32 sockIP = station_list[stationNum].IP;
        LDS     R17, stationNum
        LDI     R16, 54
        MUL     R17, R16
        LDI     R20, LOW(station_list)
        LDI     R21, (station_list) >> 8
        ADD     R20, R0
        ADC     R21, R1
        CALL    __eeget32_16
        MOVW    R25:R24, R17:R16
        MOVW    R27:R26, R19:R18
//  427       UREG s2=0;
        CLR     R9
//  428       i=0;
??GET_hook_19:
        INC     R10
//  429       
//  430       while (i++<4)
//  431       {
//  432         _i2a(i2a_buf, (UREG)(sockIP));
        MOV     R16, R24
        LDI     R17, 0
        MOVW    R31:R30, R29:R28
        CALL    _i2a
//  433         do
//  434         {
//  435   	  *d++=*sIP++;// "IP"
??GET_hook_20:
        MOVW    R31:R30, R5:R4
        LD      R16, Z
        MOVW    R31:R30, R7:R6
        ST      Z+, R16
        MOVW    R7:R6, R31:R30
//  436           s2++;
        INC     R9
//  437         }
//  438         while (*sIP);                
        LDI     R16, 1
        ADD     R4, R16
        LDI     R16, 0
        ADC     R5, R16
        MOVW    R31:R30, R5:R4
        LD      R16, Z
        TST     R16
        BRNE    ??GET_hook_20
//  439         sIP=i2a_buf;
        MOVW    R5:R4, R29:R28
//  440         if (i<4) {*d++='.';s2++;}
        LDI     R16, 4
        CP      R10, R16
        BRCC    ??GET_hook_21
        LDI     R16, 46
        MOVW    R31:R30, R7:R6
        ST      Z+, R16
        MOVW    R7:R6, R31:R30
        INC     R9
//  441         sockIP=sockIP>>8;
??GET_hook_21:
        MOV     R24, R25
        MOV     R25, R26
        MOV     R26, R27
        LDI     R27, 0
//  442       };           
        BRCS    ??GET_hook_19
//  443       
//  444       i=sizeof(req3)-1;
//  445       s=req3;
        LDI     R16, LOW((??req1 + 23))
        LDI     R17, HIGH((??req1 + 23))
        LDI     R18, 66
//  446       do
//  447       {
//  448 	*d++=*s++;// ""
??GET_hook_22:
        MOVW    R31:R30, R17:R16
        LPM     R19, Z+
        MOVW    R17:R16, R31:R30
        MOVW    R31:R30, R7:R6
        ST      Z+, R19
        MOVW    R7:R6, R31:R30
//  449       }
//  450       while(--i);                  
        DEC     R18
        BRNE    ??GET_hook_22
//  451       return (sizeof(req1)-1)+s1+s2+(sizeof(req2)-1)+(sizeof(req3)-1);
        ADD     R8, R9
        LDI     R16, 87
        ADD     R16, R8
??GET_hook_8:
        ADIW    R29:R28, 4
        LD      R24, Y+
        LD      R25, Y+
        LD      R4, Y+
        LD      R5, Y+
        LD      R6, Y+
        LD      R7, Y+
        LD      R8, Y+
        LD      R9, Y+
        LD      R10, Y+
        RET
//  452     }
//  453     return 0;
//  454   }
//  455   return 0;
//  456 }

        RSEG NEAR_F:CODE:NOROOT(0)
`?<Constant "Buffering">`:
        DC8 "Buffering"
        DC8 "icy-br"
        DC8 "icy-metaint"

        RSEG NEAR_F:CODE:NOROOT(0)
`?<Constant "Stoped">`:
        DC8 "Stoped"

        RSEG NEAR_F:CODE:NOROOT(0)
??req1:
        DC8 "GET /"
        DC8 " HTTP/1.0\015\012Host:"
        DC8 0DH, 0AH, 49H, 63H, 79H, 2DH, 4DH, 65H
        DC8 74H, 61H, 44H, 61H, 74H, 61H, 3AH, 31H
        DC8 0DH, 0AH, 55H, 73H, 65H, 72H, 2DH, 41H
        DC8 67H, 65H, 6EH, 74H, 3AH, 20H, 75H, 45H
        DC8 74H, 68H, 52H, 61H, 64H, 69H, 6FH, 2FH
        DC8 30H, 2EH, 31H, 0DH, 0AH, 43H, 6FH, 6EH
        DC8 6EH, 65H, 63H, 74H, 69H, 6FH, 6EH, 3AH
        DC8 20H, 63H, 6CH, 6FH, 73H, 65H, 0DH, 0AH
        DC8 0DH, 0AH, 0

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DC16    0
        REQUIRE ?need_segment_init

        END
// 
//     3 bytes in segment ABSOLUTE
// 1 588 bytes in segment CODE
//     6 bytes in segment INITTAB
//   126 bytes in segment NEAR_F
//    82 bytes in segment NEAR_Z
// 
// 1 714 bytes of CODE memory (+ 6 bytes shared)
//    82 bytes of DATA memory (+ 3 bytes shared)
//
//Errors: none
//Warnings: none
